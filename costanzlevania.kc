static grav = 10.0;
          
// tiles
struct { x; y; w; h; } tile_t;
// Rect, rather an aabb
struct { x; y; w; h; } rect_t;
struct { x; y; } vec2d_t;
// the player
struct { 
   x; 
   y;
   mapx;
   mapy;
   rect_t aabb; 
   xvel; 
   yvel; 
   w; 
   h; 
   grounded; } player_t;
   
static p_debugcol[3] = { 255,255,255 };

static jump_vel = 450.0;  
static p_movesp = 200.0;   
static y_floor;

static bstatus, obstatus;

#define true                     1
#define false                    0
// Change this value to manipulate how many tiles
// take up the screen width and height
#define MAX_SCREEN_TILES_ACROSS 12
#define WORLD_LENGTH_TILES      24
#define WORLD_HEIGHT_TILES      24

enum { TEX, LINE };

static stime, otime, dtime;
static screenx, screeny, tilesizx, tilesizy;
static player_t p;

static NUM_BLOCKS;
static tile_t blocks[WORLD_HEIGHT_TILES*WORLD_LENGTH_TILES];

// 24x24 map; This will be used to test horizontal and vertical scrolling...
static world[WORLD_HEIGHT_TILES][WORLD_LENGTH_TILES] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

() { // The 'main' entry point for the program...
   glenable( GL_ALPHA_TEST );
   
   if ( numframes == 0 ) {
      screenx = 0; screeny = 0;
      tilesizx = 32;
      tilesizy = 32;
      
      y_floor = yres/2;      

      // init the player
      p.x = 15*tilesizx + tilesizx/2;
      p.y = 15*tilesizy + tilesizy/2;
      p.mapx = floor(p.x/tilesizx);
      p.mapy = floor(p.y/tilesizy);
      p.xvel = 0;
      p.yvel = 0;
      p.w = 30;            
      p.h = 48;
      p.grounded = false;
      // init player aabb
      p.aabb.x = p.x;
      p.aabb.y = p.y;
      p.aabb.w = p.w;
      p.aabb.h = p.h;
      
      // initialize the blocks array
      init_blocks();                   
   }
   
   while ( true ) {
      cls( 0 );
      otime = stime;
      stime = klock();
      drawworld();
      // print the dtime
      moveto( 0,0 );
      printf( "delta time: %f", dtime );
      drawdebugmap();
      
      //drawplayer( p.x, p.y, 32, 48 );
      p_move(p, dtime);
      p_update(p, dtime);
      draw_debugplayer( p );
      
      scroll( dtime*256 );  
      dtime = stime - otime;    
      refresh();
   }
}

// Initialize the array of blocks
init_blocks() {
   i = 0;
   for ( y=0; y<WORLD_HEIGHT_TILES; y++ ) {
      for ( x=0; x<WORLD_LENGTH_TILES; x++ ) {
         if ( WORLD[y][x] == 1 ) {
            // put it into blocks
            tile_t b;
            //b.x = x*tilesizx;
            //b.y = y*tilesizy;
            b.x = screenx+(x*tilesizx)+tilesizx/2;
            b.y = screeny+(y*tilesizy)+tilesizy/2;
            b.w = tilesizx;
            b.h = tilesizy;
            blocks[i] = b;
            i++;
         }
      }
   }
   NUM_BLOCKS = i;
}

scroll ( movspd ) {
   if ( keystatus[0xcb] ) { // Left arrow-key
      if ( screenx < 0 ) {
         //screenx += movspd;
      }
   } 
   if ( keystatus[0xcd] ) { // Right arrow-key
      if ( screenx > xres - tilesizx*WORLD_LENGTH_TILES ) {
         //screenx -= movspd;
      }
   } 
   if ( keystatus[0xc8] ) {
      if ( screeny < 0 ) {
         //screeny += movspd;
      }
   } 
   if ( keystatus[0xd0] ) {
      if ( screeny > yres - tilesizy*WORLD_HEIGHT_TILES ) {
         //screeny -= movspd;
      }
   }
}

// ======== Drawing Fucntions =======

drawplayer ( x, y, w, h ) {
   glsettex( "images/alucardIdle1.png" );
   drawspr( x, y, 16, 32, 0 );
}

draw_debugplayer ( player_t p ) {
   // Draw a simple rect to be the player for now
   setcol( p_debugcol[0], p_debugcol[1], p_debugcol[3] );
   draw_rect( p.x, p.y, p.w, p.h );
   // draw the center of the player too.
   moveto( p.x-1, p.y );
   lineto( p.x+1, p.y );
   setcol( 255,255,255 );          
   
   // let's draw some debug nums
   moveto( p.x, p.y-(p.h/2)-10 );
   printf( "x: %.0f, y: %.0f", p.x, p.y );
   moveto( p.x, p.y-(p.h/2)-20 );
   printf( "mapx: %.0f, mapy: %.0f", p.mapx, p.mapy );
   moveto( p.x, p.y-(p.h/2)-30 );
   printf( "xvel: %.0f, %.0f", p.xvel, p.yvel ); 
   moveto( p.x, p.y-(p.h/2)-40 );
}

drawworld () {
   glsettex( "wood.png" );
   // GL drawing origin starts in middle of sprite
   spx = screenx + tilesizx/2; spy = screeny + tilesizy/2;
   for ( y = 0; y < WORLD_HEIGHT_TILES; y++ ) {
      for ( x = 0; x < WORLD_LENGTH_TILES; x++ ) {
         if ( world[y][x] == 0 ) {
            glsettex( "wood.png" );
         } else if ( world[y][x] = 1 ) {
            glsettex( "brick.png" );
         }
         drawspr( spx, spy, tilesizx/2, tilesizy/2, 0 );
         spx += tilesizx;
      }
      spx = screenx + tilesizx/2;
      spy += tilesizy;
   }
}

drawdebugmap () {
   // Rect drawing starts from what would be the top left corner of the rect
   spx = screenx + tilesizx/2;
   spy = screeny + tilesizy/2;
   for ( y = 0; y < WORLD_HEIGHT_TILES; y++ ) {
      for (x = 0; x < WORLD_LENGTH_TILES; x++ ) {
         if ( world[y][x] == 1 ) {
            draw_rect( spx, spy, tilesizx, tilesizy );
            setcol( 255,0,255 );
            setpix( spx, spy );
            setcol( 255,255,255 );
         }
         spx += tilesizx;   
      }
      // reset the x pos
      spx = screenx + tilesizx/2;
      spy += tilesizy;
   }
}

// modify this to treat x,y as the center
draw_rect( x,y,w,h ) {
   // calc the corner points from the
   // center.
   hw = w/2;
   hh = h/2;
   
   vec2d_t p1;
   vec2d_t p2;
   vec2d_t p3;
   vec2d_t p4;
   
   p1.x = x - hw;
   p1.y = y - hh;
   p2.x = x + hw;
   p2.y = y - hh;
   p3.x = x + hw;
   p3.y = y + hh;
   p4.x = x - hw;
   p4.y = y + hh;
   
   moveto(p1.x, p1.y);
   lineto(p2.x, p2.y);
   moveto(p2.x, p2.y);
   lineto(p3.x, p3.y);
   moveto(p3.x, p3.y);
   lineto(p4.x, p4.y);
   moveto(p4.x, p4.y);
   lineto(p1.x, p1.y);
}

// =========Player Functions==========

// update the player velocity and such
p_update(player_t p, dt) {    
   
   // apply gravity
   //p_apply_grav( p, dt );
   if ( p.grounded == false ) {
      p.yvel = p.yvel + grav;
   }
   // apply movement
   p_move( p, dt );
   
   // check for collisions against the world
   aabb_collision( p, dt );
   
   p.aabb.x += p.xvel * dt;
   p.aabb.y += p.yvel * dt;
      
   p.x = p.aabb.x;
   p.y = p.aabb.y;   
   
   p.mapx = floor( p.x/tilesizx );
   p.mapy = floor( p.y/tilesizy );
}

p_move( player_t p, dt ) {
   // Player movement
   if (keystatus[0xcb] == 1) {
      p.xvel = -1 * p_movesp;
   }
     
   if (keystatus[0xcd] == 1) {
      p.xvel = p_movesp;
   }
   
   if (keystatus[0xcb] == 0
      && keystatus[0xcd] == 0) {
      p.xvel = 0;
   }                    
            
   if (keystatus[0x39] == 1) {
      //p_jump(p, dt);
      p.yvel = -1 * jump_vel;
   }
   
   if (keystatus[0xd0] == 1) {
      //p.y += 10;
   } 
}

// Player movement funcitons
p_jump( player_t p, dt ) {
   p.yvel = -1 * jump_vel;
}

p_apply_grav( player_t p, dt ) {
   p.yvel = p.yvel + grav;
} 

aabb_collision ( player_t p, dt ) {
   // grab some player info
   rect_t a = p.aabb;
   dx = p.xvel*dt; dy = p.yvel*dt;
   pw = a.w; ph = a.h;
      
   // use the blocks array to check for collisions
   for ( i=0; i<NUM_BLOCKS; i++ ) {
      tile_t b = blocks[i];
      
      setcol( 0x00ff00 );
      setpix( b.x, b.y );
      setcol( 0xffffff );
      
      if ( a.x+pw/2 > b.x-b.w/2 && a.x-pw/2 < b.x+b.w/2 ) {
         // check for and resolve y cols
         // collision with top side of player
         if ( a.y-ph/2 > b.y+b.h/2 && a.y-ph/2 + dy < b.y+b.h/2 ) {
            // move the player flush against the bottom of b
            // not quite flush...
            a.y = (b.y + b.h/2) + ph/2;
            p.yvel = 0;  
         }
         // collision with bottom side of player
         if ( a.y+ph/2 < b.y-b.h/2 && a.y+ph/2 + dy > b.y-b.h/2 ) {
            // move the player flush against the top of b
            a.y = b.y - b.h/2 - ph/2;
            p.yvel = 0;
         }
      }
      if ( a.y+ph/2 > b.y-b.h/2 && a.y-ph/2 < b.y+b.h/2 ) {
         // check for and resolve x cols
         // collsion with left side of player
         if ( a.x-pw/2 > b.x+b.w/2 && a.x-pw/2 + dx < b.x+b.w/2 ) {
            // set the player flush against the right side of b
            a.x = b.x + b.w/2 + pw/2;
            p.xvel = 0;
         }
         // collision with the right side of the player
         if ( a.x+pw/2 < b.x-b.w/2 && a.x+pw/2 + dx > b.x-b.w/2 ) {
            // set the player flush against the left side of b
            a.x = b.x - b.w/2 - pw/2;
            p.xvel = 0;
         }
      }  
   }
}

// Simple aabb collision
aabb_col_simple( rect_t a, rect_t b ) {

   return ((a.x-a.w/2 < b.x+b.w/2 && a.x+a.w/2 > b.x-b.w/2) &&
           (a.y-a.h/2 < b.y+b.h/2 && a.y+a.h/2 > b.y-b.h/2))

}

// vector maths ==============================
project ( vec2d_t u, vec2d_t v, vec2d_t res ) {
   // [(u dot v)/(u dot u)]*u
   udv = dot( u, v );
   vdv = dot( v, v );
   res.x = (udv/vdv)*v.x;
   res.y = (udv/vdv)*v.y;
}

dot ( vec2d_t u, vec2d_t v ) {
   // u1*v1 + u2*v2
   return u.x*v.x + u.y*v.y;
}

dot_2d ( x1, y1, x2, y2 ) {
   return (x1*x2)+(y1*y2);
}

len ( vec2d_t u ) {
   sqrt ( u.x*u.x + u.y*u.y );
}
// ==============================