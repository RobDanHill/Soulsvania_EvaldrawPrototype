#define true                     1
#define false                    0

// Change this value to manipulate how many tiles
// take up the screen width and height
#define MAX_SCREEN_TILES_ACROSS 12

#define WORLD_LENGTH_TILES      24
#define WORLD_HEIGHT_TILES      24

// Rect, rather an aabb
struct { x; y; w; h; } rect_t;
struct { x; y; } vec2d_t;

static grav = 10.0;
// Move these into the player struct
static jump_vel = 450.0;  
static p_movesp = 200.0; 
struct {
   w;
   h;
   xvel;
   yvel;
   grounded;
   rect_t aabb;
   vec2d_t screen;// Screen coordinates of player
   vec2d_t map;   // Pixel location of player in map
   vec2d_t tile;  // Current tile of the player
} player_t;

static NUM_BLOCKS;
static rect_t blocks[WORLD_HEIGHT_TILES*WORLD_LENGTH_TILES];

static stime, otime, dtime;

static screenx, screeny, minispx, minispy, 
       scale, screenxres, screenyres, tilesizx, tilesizy;
       
// Use this to determine the top-left corner that the viewport
// begins drawing at...
static vec2d_t currtile, parallax;

// Use this to test proper map scrolling with the inclusion of a player...
static player_t p;

// 24x24 map; This will be used to test horizontal and vertical scrolling...
static world[WORLD_HEIGHT_TILES][WORLD_LENGTH_TILES] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

() { // The 'main' entry point for the program...

   glenable( GL_ALPHA_TEST );

   if ( numframes == 0 ) {
      screenxres = xres; screenyres = yres;
      screenx = 0; screeny = 0;
      currtile.x = 0; currtile.y = 0;
      parallax.x = 0; parallax.y = 0;
      tilesizx = screenxres/MAX_SCREEN_TILES_ACROSS;
      tilesizy = screenyres/MAX_SCREEN_TILES_ACROSS;
      scale = 8;
      /*p.map.x = p.tile.x*tilesizx+tilesizx/2;
      p.map.y = p.tile.y*tilesizy;*/

      // init the player
      p.tile.x = 20; p.tile.y = 10;
      p.map.x = p.tile.x*tilesizx+tilesizx/2;
      p.map.y = p.tile.y*tilesizy;
      p.xvel = 0;
      p.yvel = 0;
      p.w = /*30*/tilesizx;            
      p.h = /*48*/tilesizy*2;
      p.grounded = false;
      // init player aabb
      p.aabb.x = p.map.x;
      p.aabb.y = p.map.y;
      p.aabb.w = p.w-20;
      p.aabb.h = p.h-8;

      // Initialize the blocks array
      init_blocks();
   }

   while ( true ) {
      otime = stime;
      stime = klock();
      drawworld_opt();
      //drawminimap( 8, 20, 20 );
      //drawminimap_opt( 8, 20, 20 );
      drawplayer();
      //scroll( dtime*256 );
      //moveplayer( dtime*256, dtime*256 );
      p_update( p, dtime );
      dtime = stime - otime;
      refresh();
   }

}

// Initialize the array of blocks
init_blocks() {
   i = 0;
   for ( y=0; y<WORLD_HEIGHT_TILES; y++ ) {
      for ( x=0; x<WORLD_LENGTH_TILES; x++ ) {
         if ( WORLD[y][x] == 1 ) {
            // put it into blocks
            rect_t b;
            //b.x = x*tilesizx;
            //b.y = y*tilesizy;
            b.x = screenx+(x*tilesizx)+tilesizx/2;
            b.y = screeny+(y*tilesizy)+tilesizy/2;
            b.w = tilesizx;
            b.h = tilesizy;
            blocks[i] = b;
            i++;
         }
      }
   }
   NUM_BLOCKS = i;
}

// PLAYER FUNCTIONS =================================================
// update the player velocity and such
p_update(player_t p, dt) {    
   
   // apply gravity
   //p_apply_grav( p, dt );
   if ( p.grounded == false ) {
      p.yvel = p.yvel + grav;
   }
   // apply movement
   //p_move( p, dt );
   moveplayer( dt, dt );
   
   // check for collisions against the world
   aabb_collision( p, dt );
   
   p.aabb.x += p.xvel * dt;
   p.aabb.y += p.yvel * dt;  
   
   // update the player map coords
   p.map.x = p.aabb.x;
   p.map.y = p.aabb.y;
}

moveplayer( dx, dy ) {
   // Player movement
   if (keystatus[0xcb] == 1) {
      if ( p.map.x > 0 ) {
         p.xvel = -1 * p_movesp;
         if ( p.screen.x == screenxres/2 ) parallax.x += dx/scale;
      }
   }
     
   if (keystatus[0xcd] == 1) {
      if ( p.map.x < tilesizx*WORLD_LENGTH_TILES ) {
         p.xvel = p_movesp;
         if ( p.screen.x == screenxres/2 ) parallax.x -= dx/scale;
      }
   }
   
   if (keystatus[0xcb] == 0
      && keystatus[0xcd] == 0) {
      p.xvel = 0;
   }                    
            
   if (keystatus[0x39] == 1) {
      //p_jump(p, dt);
      if ( p.map.y > 0 ) { 
         p.yvel = -1 * jump_vel;
         if ( p.screen.y == screenyres/2 ) parallax.y += dy/scale;
      }
   }
   
   screenx = p.map.x - screenxres/2;
   screeny = p.map.y - screenyres/2;
   
   /* Update player tile here */
   p.tile.x = p.map.x/tilesizx;
   p.tile.y = p.map.y/tilesizy;
   
   /* Update screen coordinates here */
   outrimx = tilesizx*WORLD_LENGTH_TILES - tilesizx*MAX_SCREEN_TILES_ACROSS;
   outrimy = tilesizy*WORLD_HEIGHT_TILES - tilesizy*MAX_SCREEN_TILES_ACROSS;
   p.screen.x = min( p.map.x, max( screenxres/2, p.map.x - outrimx ) );
   p.screen.y = min( p.map.y, max( screenyres/2, p.map.y - outrimy ) );
   
   moveto( screenxres - 150, 25 );
   printf( "px: %g, py: %g", int( p.tile.x ), int( p.tile.y ) );
   
   screenx = -max( 0, min( screenx, tilesizx*WORLD_LENGTH_TILES - screenxres ) );
   screeny = -max( 0, min( screeny, tilesizy*WORLD_HEIGHT_TILES - screenyres ) );
}

p_jump( player_t p, dt ) {
   p.yvel = -1 * jump_vel;
}

p_apply_grav( player_t p, dt ) {
   p.yvel = p.yvel + grav;
} 
// END PLAYER FUNCTIONS =============================================

scroll ( movspd ) {
   //moveto( xres - 100, 25 );
   //printf( "movspd: %g", movspd );
   if ( screenx < 0 ) {
      screenx += movspd;
      parallax.x += movspd/scale;
      currtile.x -= movspd/tilesizx;
      minispx -= movspd/scale;
   }
   if ( screenx > screenxres - tilesizx*WORLD_LENGTH_TILES ) {
      screenx -= movspd;
      parallax.x -= movspd/scale;
      currtile.x += movspd/tilesizx;
      minispx += movspd/scale;
   }
   if ( screeny < 0 ) {
      screeny += movspd;
      parallax.y += movspd/scale;
      currtile.y -= movspd/tilesizy;
      minispy -= movspd/scale;
   }
   if ( screeny > screenyres - tilesizy*WORLD_HEIGHT_TILES ) {
      screeny -= movspd;
      parallax.y -= movspd/scale;
      currtile.y += movspd/tilesizy;
      minispy += movspd/scale;
   }
}

drawplayer () {
   glsettex( "Images/alucardIdle1.png" );
   draw_rect( 
      p.screen.x,
      p.screen.y, 
      p.aabb.w,
      p.aabb.h
   );
   drawspr(
      p.screen.x,
      p.screen.y,
      p.w/2,
      p.h/2,
      0
   );
}

drawworld_opt () {
   /* Parallax layer drawing code goes here */
   glsettex( "wood.png" );
   u = parallax.x*-50/xres;
   v = parallax.y*-50/yres;
   glbegin(GL_QUADS); gldisable(GL_DEPTH_TEST);
   gltexcoord(u,v); glvertex(0,0);
   gltexcoord(u+MAX_SCREEN_TILES_ACROSS,v); glvertex(xres,0);
   gltexcoord(u+MAX_SCREEN_TILES_ACROSS,v+MAX_SCREEN_TILES_ACROSS); glvertex(xres,yres);
   gltexcoord(u,v+MAX_SCREEN_TILES_ACROSS); glvertex(0,yres);
   
   /* Foreground layer drawing code goes here */
   tx = p.tile.x - MAX_SCREEN_TILES_ACROSS/2; ty = p.tile.y - MAX_SCREEN_TILES_ACROSS/2;
   x0 = max( floor( tx ), 0 ); x1 = min( ceil( tx + MAX_SCREEN_TILES_ACROSS ), WORLD_LENGTH_TILES );
   y0 = max( floor( ty ), 0 ); y1 = min( ceil( ty + MAX_SCREEN_TILES_ACROSS ), WORLD_HEIGHT_TILES );
   if ( p.tile.x < MAX_SCREEN_TILES_ACROSS/2 ) x1 = x0 + ( MAX_SCREEN_TILES_ACROSS - x0 );
   if ( p.tile.y < MAX_SCREEN_TILES_ACROSS/2 ) y1 = y0 + ( MAX_SCREEN_TILES_ACROSS - y0 );
   if ( p.tile.x > WORLD_LENGTH_TILES - MAX_SCREEN_TILES_ACROSS/2 ) x0 = WORLD_LENGTH_TILES - MAX_SCREEN_TILES_ACROSS;
   if ( p.tile.y > WORLD_HEIGHT_TILES - MAX_SCREEN_TILES_ACROSS/2 ) y0 = WORLD_HEIGHT_TILES - MAX_SCREEN_TILES_ACROSS;
   for( y = y0; y < y1; y++ ) {
      for( x = x0; x < x1; x++ ) {
         spx = screenx + tilesizx/2 + tilesizx*x;
         spy = screeny + tilesizy/2 + tilesizy*y;
              if ( world[y][x] == 0 ) { continue; glsettex("wood.png"); }
         else if ( world[y][x] == 1 ) { glsettex( "brick.png" ); }
         drawspr( spx, spy, tilesizx/2, tilesizy/2, 0 );
      }
   }
}

/* Simply render various pieces of debug info about the player */
draw_debugplayer ( player_t p ) {
   // Draw a simple rect to be the player for now
   setcol( 255, 0, 0 );
   draw_rect( p.aabb.x, p.aabb.y, p.aabb.w, p.aabb.h );
   // draw the center of the player too.
   moveto( p.map.x-1, p.map.y );
   lineto( p.map.x+1, p.map.y );
   setcol( 255,255,255 );          
   
   // let's draw some debug nums
   moveto( p.map.x, p.map.y-(p.h/2)-10 );
   printf( "x: %.0f, y: %.0f", p.map.x, p.map.y );
   moveto( p.map.x, p.map.y-(p.h/2)-20 );
   printf( "mapx: %.0f, mapy: %.0f", p.map.x, p.map.y );
   moveto( p.map.x, p.map.y-(p.h/2)-30 );
   printf( "xvel: %.0f, %.0f", p.xvel, p.yvel ); 
   moveto( p.map.x, p.map.y-(p.h/2)-40 );
}

/* drawdebugmap() still needs to be refactored to implement
   the optimized drawing algorithm... */
drawdebugmap () {
   // Rect drawing starts from what would be the top left corner of the rect
   spx = screenx + tilesizx/2;
   spy = screeny + tilesizy/2;
   for ( y = 0; y < WORLD_HEIGHT_TILES; y++ ) {
      for ( x = 0; x < WORLD_LENGTH_TILES; x++ ) {
         if ( world[y][x] == 1 ) {
            draw_rect( spx, spy, tilesizx, tilesizy );
         }
         spx += tilesizx;   
      }
      // reset the x pos
      spx = screenx + tilesizx/2;
      spy += tilesizy;
   }
}

drawminimap ( miniscale, xpad, ypad ) {
   if ( numframes == 0 ) {
      scale = miniscale;
   }
   newtilesizx = tilesizx/scale;
   newtilesizy = tilesizy/scale;
   
   tx = int(currtile.x); ty = int(currtile.y);
   
   //moveto( xres - 100, 50 );
   //printf( "tx: %g", tx );
   //moveto( xres - 100, 75 );
   //printf( "ty: %g", ty );

   // Rect drawing starts from what would be the top left corner of the rect
   spx = xres - xpad - WORLD_LENGTH_TILES*newtilesizx + newtilesizx/2;
   spy = yres - ypad - WORLD_HEIGHT_TILES*newtilesizy + newtilesizy/2;
   for ( y = 0; y < WORLD_HEIGHT_TILES; y++ ) {
      for ( x = 0; x < WORLD_LENGTH_TILES; x++ ) {
         if ( world[y][x] == 1 ) {
            draw_rect( spx, spy, newtilesizx, newtilesizy );
         }
         spx += newtilesizx;   
      }
      // reset the x pos
      spx = xres - xpad - WORLD_LENGTH_TILES*newtilesizx + newtilesizx/2;
      spy += newtilesizy;
   }
   if ( numframes == 0 ) {
      minispx = xres - xpad - WORLD_LENGTH_TILES*newtilesizx + 
                 MAX_SCREEN_TILES_ACROSS*newtilesizx/2;
      minispy = yres - ypad - WORLD_HEIGHT_TILES*newtilesizy + 
                 MAX_SCREEN_TILES_ACROSS*newtilesizy/2;
   }
   draw_rect( 
      minispx, 
      minispy, 
      MAX_SCREEN_TILES_ACROSS*newtilesizx, 
      MAX_SCREEN_TILES_ACROSS*newtilesizy 
   );
}

/* drawminimap_opt() essentially shows how the optimized 
   drawing algorithm works in real time... */
drawminimap_opt ( miniscale, xpad, ypad ) {
   if ( numframes == 0 ) scale = miniscale;
   newtilesizx = tilesizx/scale;
   newtilesizy = tilesizy/scale;
   
   tx = p.tile.x - MAX_SCREEN_TILES_ACROSS/2; ty = p.tile.y - MAX_SCREEN_TILES_ACROSS/2;
   
   moveto( xres - 100, 50 );
   printf( "tx: %g", tx );
   moveto( xres - 100, 75 );
   printf( "ty: %g", ty );
   
   spx = xres - xpad - ( WORLD_LENGTH_TILES - tx )*newtilesizx + newtilesizx/2;
   spy = yres - ypad - ( WORLD_HEIGHT_TILES - ty )*newtilesizy + newtilesizy/2;
   
   x0 = max(floor(tx),0); x1 = min(ceil(tx+MAX_SCREEN_TILES_ACROSS),WORLD_HEIGHT_TILES);
   y0 = max(floor(ty),0); y1 = min(ceil(ty+MAX_SCREEN_TILES_ACROSS),WORLD_HEIGHT_TILES);
   for(y=y0;y<y1;y++) {
      for(x=x0;x<x1;x++)
      {
         spx = xres - xpad - screenx/scale + newtilesizx/2 + newtilesizx*x;
         spy = yres - ypad - screeny/scale + newtilesizy/2 + newtilesizy*y;
         if (world[y][x] == 1) { draw_rect(spx,spy,newtilesizx,newtilesizy); }
      }
   }
   
#if 0
   for ( y = max( 0, ty-1 ); y < WORLD_HEIGHT_TILES && 
         y < ( ty+MAX_SCREEN_TILES_ACROSS+1 ); y++ ) {
      for ( x = max( 0, tx-1 ); x < WORLD_LENGTH_TILES && 
         x < ( tx+MAX_SCREEN_TILES_ACROSS+1 ); x++ ) {
         if ( world[y][x] == 1 ) {
            draw_rect( spx, spy, newtilesizx, newtilesizy );
         }
         spx += newtilesizx;
      }
      // Reset the xpos
      spx = xres - xpad - ( WORLD_LENGTH_TILES - max( 0, tx-1 ) )*newtilesizx + newtilesizx/2;
      spy += newtilesizy;
   }
#endif
   
   if ( numframes == 0 ) {
      minispx = xres - xpad - ( WORLD_LENGTH_TILES - tx )*newtilesizx + 
                 MAX_SCREEN_TILES_ACROSS*newtilesizx/2;
      minispy = yres - ypad - ( WORLD_HEIGHT_TILES - ty )*newtilesizy + 
                 MAX_SCREEN_TILES_ACROSS*newtilesizy/2;
   }
   
   // Draw the viewport rectangle
   draw_rect( 
      minispx, 
      minispy, 
      MAX_SCREEN_TILES_ACROSS*newtilesizx, 
      MAX_SCREEN_TILES_ACROSS*newtilesizy 
   );
}

// modify this to treat x,y as the center
draw_rect( x, y, w, h ) {
   // calc the corner points from the
   // center.
   hw = w/2;
   hh = h/2;
   
   vec2d_t p1;
   vec2d_t p2;
   vec2d_t p3;
   vec2d_t p4;
   
   p1.x = x - hw;
   p1.y = y - hh;
   p2.x = x + hw;
   p2.y = y - hh;
   p3.x = x + hw;
   p3.y = y + hh;
   p4.x = x - hw;
   p4.y = y + hh;
   
   moveto(p1.x, p1.y);
   lineto(p2.x, p2.y);
   lineto(p3.x, p3.y);
   lineto(p4.x, p4.y);
   lineto(p1.x, p1.y);
}

// COLLISION FUNCTIONS ==============================================
aabb_collision ( player_t p, dt ) {
   // grab some player info
   rect_t a = p.aabb;
   dx = p.xvel*dt; dy = p.yvel*dt;
   pw = a.w; ph = a.h;
   on_ground = false;
      
   // use the blocks array to check for collisions
   for ( i=0; i<NUM_BLOCKS; i++ ) {
      rect_t b = blocks[i];
      
      if ( a.x+pw/2 > b.x-b.w/2 && a.x-pw/2 < b.x+b.w/2 ) {
         // check for and resolve y cols
         // collision with top side of player
         if ( a.y-ph/2 > b.y+b.h/2 && a.y-ph/2 + dy < b.y+b.h/2 ) {
            // move the player flush against the bottom of b
            // not quite flush...
            a.y = (b.y + b.h/2) + ph/2;
            p.yvel = 0;  
         }
         // collision with bottom side of player
         if ( a.y+ph/2 < b.y-b.h/2 && a.y+ph/2 + dy > b.y-b.h/2 ) {
            // move the player flush against the top of b
            a.y = b.y - b.h/2 - ph/2;
            p.yvel = 0;
            on_ground = true;
         }
      }
      if ( a.y+ph/2 > b.y-b.h/2 && a.y-ph/2 < b.y+b.h/2 ) {
         // check for and resolve x cols
         // collsion with left side of player
         if ( a.x-pw/2 > b.x+b.w/2 && a.x-pw/2 + dx < b.x+b.w/2 ) {
            // set the player flush against the right side of b
            a.x = b.x + b.w/2 + pw/2;
            p.xvel = 0;
         }
         // collision with the right side of the player
         if ( a.x+pw/2 < b.x-b.w/2 && a.x+pw/2 + dx > b.x-b.w/2 ) {
            // set the player flush against the left side of b
            a.x = b.x - b.w/2 - pw/2;
            p.xvel = 0;
         }
      }  
   }
   
   if ( on_ground == true ) {
      p.grounded = true;
   } else {
      p.grounded = false;
   }
}

// Simple aabb collision
aabb_col_simple( rect_t a, rect_t b ) {

   return ((a.x-a.w/2 < b.x+b.w/2 && a.x+a.w/2 > b.x-b.w/2) &&
           (a.y-a.h/2 < b.y+b.h/2 && a.y+a.h/2 > b.y-b.h/2))

}
// END COLLISION FUNCTIONS ==========================================